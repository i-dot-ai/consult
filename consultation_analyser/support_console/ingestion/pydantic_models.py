from typing import Dict, List, Literal, Optional

from pydantic import BaseModel, Field, field_validator

# ============================================================================
# Immutable data - Core consultation data not generated by AI
# ============================================================================


class RespondentInput(BaseModel):
    """
    Input model for a single respondent from respondents.jsonl.

    Example S3 file: app_data/consultations/{code}/inputs/respondents.jsonl
    Each line represents one respondent with their demographic information.
    """

    themefinder_id: int
    demographic_data: Dict[str, List[str]] = Field(default_factory=dict)

    model_config = {"extra": "forbid"}


class QuestionInput(BaseModel):
    """
    Input model for a question from question.json.

    Example S3 file: app_data/consultations/{code}/inputs/question_part_N/question.json
    Contains the question text and configuration (free text, multiple choice options).
    """

    question_text: str
    question_number: int
    has_free_text: bool = True
    multi_choice_options: List[str] = Field(default_factory=list)

    @field_validator("multi_choice_options", mode="before")
    @classmethod
    def coerce_none_to_empty_list(cls, v):
        """Ensure None values are converted to empty list"""
        return v if v is not None else []

    model_config = {"extra": "forbid"}


class ResponseInput(BaseModel):
    """
    Input model for a free text response from responses.jsonl.

    Example S3 file: app_data/consultations/{code}/inputs/question_part_N/responses.jsonl
    Each line represents one respondent's free text answer to the question.
    """

    themefinder_id: int
    text: str

    model_config = {"extra": "forbid"}


class MultiChoiceInput(BaseModel):
    """
    Input model for multi-choice selections from multi_choice.jsonl.

    Example S3 file: app_data/consultations/{code}/inputs/question_part_N/multi_choice.jsonl
    Each line represents one respondent's selected options for a multiple choice question.
    """

    themefinder_id: int
    options: List[str]

    model_config = {"extra": "forbid"}


class ImmutableDataBatch(BaseModel):
    """
    All immutable consultation data that is not dependent on AI processing.

    This represents the complete set of data needed to create the core consultation

    Immutable data is data that should not change after initial import:
    - Consultation definition
    - Respondents and their demographics
    - Questions and their configuration
    - Responses (both free text and multiple choice)
    """

    consultation_code: str
    consultation_title: str
    timestamp: Optional[str] = None
    respondents: List[RespondentInput]
    questions: List[QuestionInput]

    # Keyed by question_number for efficient lookup
    responses_by_question: Dict[int, List[ResponseInput]] = Field(default_factory=dict)
    multi_choice_by_question: Dict[int, List[MultiChoiceInput]] = Field(default_factory=dict)

    model_config = {"extra": "forbid"}


# ============================================================================
# CANDIDATE THEMES - AI-generated themes for sign-off workflow
# ============================================================================


class CandidateThemeInput(BaseModel):
    """
    Input model for a single AI-generated candidate theme from clustered_themes.json.

    Example S3 file: app_data/consultations/{code}/outputs/sign_off/{timestamp}/question_part_N/clustered_themes.json
    Contains hierarchical themes generated by themefinder, ready for human review and sign-off.
    """

    topic_id: str
    topic_label: str
    topic_description: str
    source_topic_count: int
    parent_id: str
    children: List[str] = Field(default_factory=list)

    model_config = {"extra": "allow"}


class CandidateThemeBatch(BaseModel):
    """
    All candidate themes for a consultation organized by question.

    Candidate themes are AI-generated during the themefinder workflow and stored
    in the outputs/sign_off/{timestamp}/ folder.

    The timestamp is required for candidate themes as it identifies the specific
    themefinder run that generated these themes.
    """

    consultation_code: str
    timestamp: str
    themes_by_question: Dict[int, List[CandidateThemeInput]] = Field(default_factory=dict)

    model_config = {"extra": "forbid"}


# ============================================================================
# RESPONSE ANNOTATIONS - AI-generated annotations (sentiment, themes, evidence)
# ============================================================================


class SentimentInput(BaseModel):
    """
    Input model for sentiment analysis from sentiment.jsonl.

    Example S3 file: app_data/consultations/{code}/outputs/mapping/{timestamp}/question_part_N/sentiment.jsonl
    Contains sentiment classification for each response (AGREEMENT, DISAGREEMENT, UNCLEAR).

    Note: This file may not exist for all consultations. If missing, skip sentiment ingestion.
    """

    themefinder_id: int
    sentiment: Literal["AGREEMENT", "DISAGREEMENT", "UNCLEAR"] = "UNCLEAR"

    model_config = {"extra": "forbid"}


class DetailDetectionInput(BaseModel):
    """
    Input model for evidence richness detection from detail_detection.jsonl.

    Example S3 file: app_data/consultations/{code}/outputs/mapping/{timestamp}/question_part_N/detail_detection.jsonl
    Indicates whether each response is evidence-rich (contains specific details/examples).
    """

    themefinder_id: int
    evidence_rich: Literal["YES", "NO"] = "NO"

    @property
    def as_bool(self) -> bool:
        """Convert YES/NO to boolean for database storage."""
        return self.evidence_rich == "YES"

    model_config = {"extra": "forbid"}


class ThemeMappingInput(BaseModel):
    """
    Input model for theme mappings from mapping.jsonl.

    Example S3 file: app_data/consultations/{code}/outputs/mapping/{timestamp}/question_part_N/mapping.jsonl
    Links each response to one or more themes via theme_keys.
    """

    themefinder_id: int
    theme_keys: List[str]

    model_config = {"extra": "forbid"}


class SelectedThemeInput(BaseModel):
    """
    Input model for selected themes from themes.json.

    Example S3 file: app_data/consultations/{code}/outputs/mapping/{timestamp}/question_part_N/themes.json
    Defines the themes used for this question after sign-off.
    """

    theme_key: str
    theme_name: str
    theme_description: str

    model_config = {"extra": "forbid"}


class AnnotationBatch(BaseModel):
    """
    All response annotations for a consultation organized by question.

    Response annotations are AI-generated during the mapping workflow and stored
    in the outputs/mapping/{timestamp}/ folder structure. They include:
    - Sentiment analysis (optional)
    - Evidence richness detection
    - Theme mappings (response-to-theme links)
    - Selected themes (the themes themselves)

    The timestamp is required for annotations as it identifies the specific
    mapping run that generated these outputs.
    """

    consultation_code: str
    timestamp: str
    sentiments_by_question: Dict[int, List[SentimentInput]] = Field(default_factory=dict)
    details_by_question: Dict[int, List[DetailDetectionInput]] = Field(default_factory=dict)
    mappings_by_question: Dict[int, List[ThemeMappingInput]] = Field(default_factory=dict)
    selected_themes_by_question: Dict[int, List[SelectedThemeInput]] = Field(default_factory=dict)

    model_config = {"extra": "forbid"}
